<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zombie Hunter: Modern Tank Defense</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            display: flex;
            flex-direction: column; /* Allow content to stack vertically */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a1a;
            margin: 0;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            color: #eee;
            text-shadow: 2px 2px 0px #000;
        }

        .game-container {
            position: relative;
            background-color: #333;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.6);
            padding: 20px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 5px solid #8b0000;
            margin-bottom: 20px; /* Space for mobile controls below */
        }

        h1 {
            color: #ff4500;
            margin-bottom: 20px;
            font-size: 2em;
            line-height: 1.2;
            text-transform: uppercase;
        }

        canvas {
            background-color: #444; /* This will be covered by drawBackground */
            display: block;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.7);
            border: 2px solid #555;
            cursor: default; /* Changed from 'move' as direct mouse Y control is removed for side view */
        }

        .game-info {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 15px;
            font-size: 0.9em;
            color: #eee;
            flex-wrap: wrap;
            gap: 10px;
        }

        .game-info > div {
            padding: 5px 10px;
            background-color: rgba(0, 0, 0, 0.4);
            border-radius: 5px;
        }

        .instructions {
            margin-top: 15px;
            font-size: 0.8em;
            color: #bbb;
        }

        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        button {
            padding: 12px 25px;
            font-size: 1em;
            font-family: 'Press Start 2P', cursive;
            font-weight: bold;
            color: white;
            background: linear-gradient(145deg, #2ecc71, #27ae60);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            outline: none;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease-in-out;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            transform: translateY(-2px);
            box-shadow: 0 7px 15px rgba(0, 0, 0, 0.4);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.2);
        }

        button.restart {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
        }

        button.restart:hover {
            background: linear-gradient(145deg, #c0392b, #e74c3c);
        }

        button.upgrade {
            background: linear-gradient(145deg, #3498db, #2980b9);
            display: none;
        }
        button.upgrade:hover {
            background: linear-gradient(145deg, #2980b9, #3498db);
        }

        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 10px;
            z-index: 10;
            font-size: 1.8em;
            font-weight: bold;
            color: #e74c3c;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        #game-over-screen h2 {
            margin-bottom: 10px;
            font-size: 1.2em;
            color: #eee;
            text-transform: uppercase;
        }

        #userIdDisplay {
            font-size: 0.7em;
            color: #7f8c8d;
            margin-top: 10px;
        }

        /* Mobile Controls Styling */
        .mobile-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .mobile-controls .dpad {
            display: grid;
            grid-template-columns: repeat(3, 60px); /* 3 columns */
            grid-template-rows: repeat(2, 60px); /* 2 rows */
            gap: 5px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .mobile-controls .dpad button {
            width: 60px;
            height: 60px;
            padding: 0;
            font-size: 1.5em; /* Icon size */
            background: linear-gradient(145deg, #444, #222); /* Darker background */
            color: #00ffff; /* Cyan for controls */
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.5);
            border: 2px solid #00ffff;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background 0.1s ease-in-out;
        }
        .mobile-controls .dpad button:active {
            background: linear-gradient(145deg, #00ffff, #00aaaa); /* Highlight on press */
            color: #222;
        }

        /* Grid placement for D-pad */
        .mobile-controls .dpad button:nth-child(1) { grid-column: 1; grid-row: 1; } /* Up */
        .mobile-controls .dpad button:nth-child(2) { grid-column: 2; grid-row: 1; } /* Center filler */
        .mobile-controls .dpad button:nth-child(3) { grid-column: 3; grid-row: 1; } /* Down */
        .mobile-controls .dpad button:nth-child(4) { grid-column: 1; grid-row: 2; } /* Left */
        .mobile-controls .dpad button:nth-child(5) { grid-column: 2; grid-row: 2; } /* Filler */
        .mobile-controls .dpad button:nth-child(6) { grid-column: 3; grid-row: 2; } /* Right */

        /* Specific shoot button if not part of dpad */
        .mobile-controls .shoot-button button {
            min-width: 100px;
            height: 100px;
            font-size: 1.8em;
            background: linear-gradient(145deg, #e74c3c, #c0392b); /* Red for shoot */
            color: white;
            border: 2px solid #ff0000;
            border-radius: 50%; /* Circle button */
            margin-left: 20px; /* Space from D-pad */
        }
        .mobile-controls .shoot-button button:active {
            background: linear-gradient(145deg, #c0392b, #e74c3c);
        }

        /* Hide desktop controls on small screens and show mobile controls */
        @media (max-width: 768px) {
            .button-group {
                display: none; /* Hide Start/Restart/Upgrade on mobile */
            }
            .mobile-controls {
                display: flex; /* Show mobile controls */
            }
            .instructions {
                display: none; /* Hide desktop instructions */
            }
        }
        /* Hide mobile controls on large screens and show desktop controls */
        @media (min-width: 769px) {
            .mobile-controls {
                display: none;
            }
            .button-group {
                display: flex; /* Show desktop controls */
            }
            .instructions {
                display: block; /* Show desktop instructions */
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Zombie Hunter: Modern Tank Defense</h1>
        <canvas id="gameCanvas"></canvas>
        <div class="game-info">
            <div id="scoreDisplay">Score: 0</div>
            <div id="bestScoreDisplay">Best Score: 0</div>
            <div id="tankHealthDisplay">Tank HP: 100</div>
            <div id="victimCountDisplay">Victims: 1</div>
            <div id="waveDisplay">Wave: 1</div>
        </div>
        <div id="userIdDisplay">User ID: Loading...</div>

        <div class="button-group">
            <button id="startButton">Start Game</button>
            <button id="upgradeButton" class="upgrade">Upgrade Tank (500 pts)</button>
            <button id="restartButton" class="restart" style="display: none;">Restart Game</button>
        </div>

        <!-- Mobile Controls -->
        <div class="mobile-controls">
            <div class="dpad">
                <button id="moveUpBtn">▲</button>
                <div style="grid-column: 2; grid-row: 1;"></div> <!-- Filler for center top -->
                <button id="moveDownBtn">▼</button>
                <button id="moveLeftBtn">◀</button>
                <div style="grid-column: 2; grid-row: 2;"></div> <!-- Filler for center bottom -->
                <button id="moveRightBtn">▶</button>
            </div>
            <div class="shoot-button">
                <button id="shootBtn">FIRE</button>
            </div>
        </div>


        <div id="game-over-screen" style="display: none;">
            <h2>Game Over!</h2>
            <div id="final-score"></div>
            <div id="game-over-wave"></div>
            <div id="final-best-score"></div>
        </div>

        <div class="instructions">
            Desktop: Use Left/Right/Up/Down arrow keys or 'A'/'D'/'W'/'S' to move the tank. Click/Spacebar for Main Cannon. 'M' for Machine Guns (Lasers). 'R' for Missiles. Protect the victims!
            <br>
            Mobile: Use on-screen D-pad and FIRE button (Main Cannon). Other weapons are automatic.
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Variables (declared early to ensure availability) ---
        let app;
        let db;
        let auth;
        let userId;
        let isFirebaseReady = false;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        let initialAuthCheckCompleted = false; // New flag to ensure resetGame is called only once after initial auth

        // --- Game Configuration (declared early to ensure availability) ---
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 450;
        const GROUND_Y = GAME_HEIGHT * 0.7;
        const STREET_MIN_Y_DRAW = GROUND_Y + 5;
        const STREET_MAX_Y_DRAW = GAME_HEIGHT - 10;

        const TANK_WIDTH = 130;
        const TANK_HEIGHT = 80;
        const TANK_MOVE_SPEED = 4;

        const BULLET_RADIUS = 6; // Note: actual bullet drawing uses fixed size, this is for collision
        let BULLET_SPEED = 20;
        let BULLET_DAMAGE = 10;
        let FIRE_RATE_COOLDOWN = 150; // Main cannon cooldown

        const LASER_WIDTH = 25;
        const LASER_HEIGHT = 4;
        const LASER_DAMAGE = 5;
        const LASER_SPEED = 30;
        const LASER_COOLDOWN = 100; // Machine gun laser cooldown (auto & manual)

        const MISSILE_WIDTH = 30;
        const MISSILE_HEIGHT = 10;
        const MISSILE_DAMAGE = 40;
        const MISSILE_SPEED_X = 8; // Horizontal speed
        const MISSILE_SPEED_Y_INITIAL = -15; // Initial upward vertical speed
        const MISSILE_GRAVITY = 0.5; // Gravity effect on missile
        const MISSILE_COOLDOWN = 1000; // Missile launcher cooldown (auto & manual)
        const MISSILE_ARC_HEIGHT_FACTOR = 0.5; // How high missiles arc (fraction of canvas height)

        const ZOMBIE_WIDTH = 50;
        const ZOMBIE_HEIGHT = 80;
        const ZOMBIE_INITIAL_SPEED = 0.5;
        const ZOMBIE_INITIAL_HEALTH = 30;
        const ZOMBIE_SPAWN_INTERVAL = 1500;

        const ZOMBIE_TANK_WIDTH = 180;
        const ZOMBIE_TANK_HEIGHT = 100;
        const ZOMBIE_TANK_HEALTH = 500; // Much higher health
        const ZOMBIE_TANK_SPEED = 0.3; // Slower but tougher
        const ZOMBIE_TANK_SPAWN_WAVE = 7; // When zombie tanks start appearing
        const ZOMBIE_TANK_SPAWN_CHANCE = 0.15; // Chance to spawn instead of regular zombie

        const MAX_TANK_HEALTH = 100;
        const VICTIM_INITIAL_COUNT = 1;
        const VICTIM_DAMAGE_PER_ZOMBIE = 20;
        const VICTIM_WIDTH = 30;
        const VICTIM_HEIGHT = 60;
        const VICTIM_Y = GROUND_Y - VICTIM_HEIGHT + (STREET_MAX_Y_DRAW - GROUND_Y - VICTIM_HEIGHT) / 2;

        const VICTIM_HEAD_RADIUS = 8;
        const VICTIM_BODY_WIDTH = 20;
        const VICTIM_BODY_HEIGHT = 30;

        const DEFENSE_LINE_X = 100;

        // Upgrade Config
        const UPGRADE_SCORE_THRESHOLDS = [100, 200, 300, 400, 500, 600, 700, 800]; // Score required for next upgrade
        const TANK_UPGRADE_LEVELS = [
            { barrelLength: TANK_WIDTH * 0.4, bulletSpeed: 20, bulletDamage: 10, fireRate: 150, name: "Basic Tank", laserEnabled: false, missileEnabled: false },
            { barrelLength: TANK_WIDTH * 0.5, bulletSpeed: 25, bulletDamage: 15, fireRate: 130, name: "Tank Mk.I", laserEnabled: false, missileEnabled: false },
            { barrelLength: TANK_WIDTH * 0.6, bulletSpeed: 30, bulletDamage: 20, fireRate: 110, name: "Tank Mk.II", laserEnabled: true, missileEnabled: false }, // MG added
            { barrelLength: TANK_WIDTH * 0.7, bulletSpeed: 35, bulletDamage: 25, fireRate: 90, name: "Tank Mk.III", laserEnabled: true, missileEnabled: false }, // Dual MG
            { barrelLength: TANK_WIDTH * 0.8, bulletSpeed: 40, bulletDamage: 30, fireRate: 70, name: "Tank Mk.IV", laserEnabled: true, missileEnabled: true }, // Missile Pods added
            { barrelLength: TANK_WIDTH * 0.9, bulletSpeed: 45, bulletDamage: 35, fireRate: 50, name: "Tank Mk.V", laserEnabled: true, missileEnabled: true },
            { barrelLength: TANK_WIDTH, bulletSpeed: 50, bulletDamage: 40, fireRate: 40, name: "Tank Mk.VI", laserEnabled: true, missileEnabled: true }, // Additional missile pods
            { barrelLength: TANK_WIDTH * 1.1, bulletSpeed: 55, bulletDamage: 45, fireRate: 30, name: "Tank Mk.VII", laserEnabled: true, missileEnabled: true },
            { barrelLength: TANK_WIDTH * 1.2, bulletSpeed: 60, bulletDamage: 50, fireRate: 20, name: "Tank Mk.MAX", laserEnabled: true, missileEnabled: true }
        ];
        let playerUpgradeLevel = 0; // Current index in TANK_UPGRADE_LEVELS

        const ZOMBIE_VISUAL_TIERS = [
            { wave: 1, name: "Shambler" },
            { wave: 3, name: "Groaner" },
            { wave: 6, name: "Fleshpound" },
            { wave: 10, name: "Crawler" }
        ];
        let currentZombieTier = 0;

        const BACKGROUND_THEMES = [
            { wave: 1, name: "Day", sky: ['#1a2a3a', '#4a3a40', '#6a5a40'], ruins: '#111', street: '#3a3a3a', lines: '#f1c40f', curb: '#222' },
            { wave: 5, name: "Sunset", sky: ['#4a0e00', '#8c2f00', '#bf7a00'], ruins: '#220000', street: '#3a3a3a', lines: '#ffa500', curb: '#222' },
            { wave: 10, name: "Night", sky: ['#050a1a', '#101a2a', '#202a3a'], ruins: '#000000', street: '#202020', lines: '#7f8c8d', curb: '#111' },
            { wave: 15, name: "Sunrise", sky: ['#1a2a3a', '#5a4a3a', '#8c7a6a'], ruins: '#222', street: '#3a3a3a', lines: '#f1c40f', curb: '#222' }
        ];
        let currentBackgroundThemeIndex = 0;

        // --- Game State Variables (declared early to ensure availability) ---
        let player = {
            x: GAME_WIDTH / 4,
            y: STREET_MIN_Y_DRAW + (STREET_MAX_Y_DRAW - STREET_MIN_Y_DRAW) / 2 - TANK_HEIGHT / 2,
            width: TANK_WIDTH,
            height: TANK_HEIGHT,
            health: MAX_TANK_HEALTH,
            currentPrimaryCooldown: 0,
            currentLaserCooldown: 0,
            currentMissileCooldown: 0,
            canFirePrimary: true,
            canFireLaser: true,
            canFireMissile: true,
            barrelLength: TANK_UPGRADE_LEVELS[0].barrelLength,
            isMovingLeft: false,
            isMovingRight: false,
            isMovingUp: false,
            isMovingDown: false
        };

        let victims = [];
        let projectiles = []; // Renamed from 'bullets' to hold all projectile types
        let zombies = [];
        let explosions = []; // To hold explosion particles
        let bloodParticles = [];
        let score = 0;
        let bestScore = 0;
        let currentWave = 1;
        let gameOver = false;
        let gameRunning = false;
        let lastZombieSpawnTime = 0;
        let animationFrameId;
        let zombieSpeed = ZOMBIE_INITIAL_SPEED;
        let zombieSpawnRate = ZOMBIE_SPAWN_INTERVAL;
        let lastUpdateTime = 0;
        let treadOffset = 0;
        const TREAD_ANIMATION_SPEED = 0.5;
        let upgradeAvailable = false;
        let tankUpgraded = false;


        // --- Blood Particle Variables ---
        const BLOOD_PARTICLE_COUNT = 20;
        const BLOOD_PARTICLE_SIZE_MIN = 2;
        const BLOOD_PARTICLE_SIZE_MAX = 6;
        const BLOOD_PARTICLE_SPEED_MAX = 8;
        const BLOOD_PARTICLE_LIFESPAN = 35;

        // --- Explosion Particle Variables ---
        const EXPLOSION_PARTICLE_COUNT = 30;
        const EXPLOSION_PARTICLE_SIZE_MIN = 5;
        const EXPLOSION_PARTICLE_SIZE_MAX = 15;
        const EXPLOSION_PARTICLE_SPEED_MAX = 10;
        const EXPLOSION_PARTICLE_LIFESPAN = 40;


        // --- DOM Element References (declared with let to be assigned inside window.onload) ---
        let canvas;
        let ctx;
        let scoreDisplay;
        let bestScoreDisplay;
        let tankHealthDisplay;
        let victimCountDisplay;
        let waveDisplay;
        let startButton;
        let upgradeButton;
        let restartButton;
        let gameOverScreen;
        let finalScoreDisplay;
        let gameOverWaveDisplay;
        let finalBestScoreDisplay;
        let userIdDisplay;
        let moveUpBtn;
        let moveDownBtn;
        let moveLeftBtn;
        let moveRightBtn;
        let shootBtn;


        // --- Utility Functions ---

        /**
         * Darkens a given hex color by a specified percentage.
         */
        function darkenColor(hex, percent) {
            let f=parseInt(hex.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent,R=f>>16,G=(f>>8)&0x00FF,B=(f)&0x0000FF;
            return "#"+(0x1000000+(Math.round((t-R)*p/100)+R)*0x10000+(Math.round((t-G)*p/100)+G)*0x100+(Math.round((t-B)*p/100)+B)).toString(16).slice(1);
        }

        /**
         * Draws a health bar.
         */
        function drawHealthBar(x, y, width, height, currentHealth, maxHealth, fillColor) {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, width, height);

            const healthWidth = (currentHealth / maxHealth) * width;
            ctx.fillStyle = fillColor;
            ctx.fillRect(x, y, healthWidth, height);
        }

        // --- Game Drawing Functions ---

        /**
         * Draws the highly detailed background based on the current theme.
         */
        function drawBackground() {
            const theme = BACKGROUND_THEMES[currentBackgroundThemeIndex];

            // Sky
            let skyGradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT * 0.7);
            skyGradient.addColorStop(0, theme.sky[0]);
            skyGradient.addColorStop(0.5, theme.sky[1]);
            skyGradient.addColorStop(1, theme.sky[2]);
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Distant city silhouette - more detailed ruins
            ctx.fillStyle = theme.ruins;
            ctx.beginPath();
            ctx.moveTo(0, GROUND_Y);
            ctx.lineTo(0, GROUND_Y - 50); // Start of a building
            ctx.lineTo(50, GROUND_Y - 80);
            ctx.lineTo(80, GROUND_Y - 60);
            ctx.lineTo(120, GROUND_Y - 100); // Tall ruin
            ctx.lineTo(150, GROUND_Y - 70);
            ctx.lineTo(200, GROUND_Y - 90);
            ctx.lineTo(250, GROUND_Y - 40);
            ctx.lineTo(300, GROUND_Y - 120); // Another tall ruin
            ctx.lineTo(350, GROUND_Y - 80);
            ctx.lineTo(400, GROUND_Y - 110);
            ctx.lineTo(450, GROUND_Y - 60);
            ctx.lineTo(500, GROUND_Y - 90);
            ctx.lineTo(550, GROUND_Y - 70);
            ctx.lineTo(600, GROUND_Y - 100);
            ctx.lineTo(650, GROUND_Y - 50);
            ctx.lineTo(700, GROUND_Y - 80);
            ctx.lineTo(GAME_WIDTH, GROUND_Y - 60);
            ctx.lineTo(GAME_WIDTH, GROUND_Y);
            ctx.closePath();
            ctx.fill();

            // Ground - asphalt street
            ctx.fillStyle = theme.street;
            ctx.fillRect(0, GROUND_Y, GAME_WIDTH, GAME_HEIGHT - GROUND_Y);

            // Street markings (dashed lines) - multiple lanes now
            ctx.fillStyle = theme.lines;
            const lineDashLength = 20;
            const lineDashGap = 30;
            const lineCount = Math.floor(GAME_WIDTH / (lineDashLength + lineDashGap));

            // Lane 1
            let laneY1 = STREET_MIN_Y_DRAW + (STREET_MAX_Y_DRAW - STREET_MIN_Y_DRAW) * 0.25;
            for (let i = 0; i < lineCount; i++) {
                ctx.fillRect(i * (lineDashLength + lineDashGap), laneY1, lineDashLength, 4);
            }
            // Lane 2
            let laneY2 = STREET_MIN_Y_DRAW + (STREET_MAX_Y_DRAW - STREET_MIN_Y_DRAW) * 0.5;
            for (let i = 0; i < lineCount; i++) {
                ctx.fillRect(i * (lineDashLength + lineDashGap), laneY2, lineDashLength, 4);
            }
            // Lane 3
            let laneY3 = STREET_MIN_Y_DRAW + (STREET_MAX_Y_DRAW - STREET_MIN_Y_DRAW) * 0.75;
            for (let i = 0; i < lineCount; i++) {
                ctx.fillRect(i * (lineDashLength + lineDashGap), laneY3, lineDashLength, 4);
            }

            // Sidewalk/Curb - darker border along the top of the street
            ctx.fillStyle = theme.curb;
            ctx.fillRect(0, GROUND_Y, GAME_WIDTH, 5); // Simple curb line
        }


        /**
         * Draws the player tank with distinct, progressively cooler appearances.
         */
        function drawPlayer() {
            const tankX = player.x - player.width / 2;
            const tankY = player.y;
            let hullColor, treadColor, turretColor, barrelColor, reactiveArmorColor, glowColor, accentColor;
            let glowBlur;

            // Define colors and base glow for each level
            switch (playerUpgradeLevel) {
                case 0: // Basic Tank
                    hullColor = '#4e5a6b';
                    treadColor = '#323b47';
                    turretColor = '#5e6c7e';
                    barrelColor = '#8d99a9';
                    reactiveArmorColor = '#6c7a89';
                    glowColor = '#00ffff';
                    accentColor = '#aa00ff';
                    glowBlur = 15;
                    break;
                case 1: // Tank Mk.I - Slightly darker, more defined lines
                    hullColor = darkenColor('#4e5a6b', 10);
                    treadColor = darkenColor('#323b47', 10);
                    turretColor = darkenColor('#5e6c7e', 10);
                    barrelColor = darkenColor('#8d99a9', 10);
                    reactiveArmorColor = darkenColor('#6c7a89', 10);
                    glowColor = '#00ffff';
                    accentColor = '#ff00aa';
                    glowBlur = 18;
                    break;
                case 2: // Tank Mk.II - More angular, better armor, Machine Guns visible
                    hullColor = '#404c5c';
                    treadColor = '#28323c';
                    turretColor = '#505f70';
                    barrelColor = '#7d8a9a';
                    reactiveArmorColor = '#7a8c9e';
                    glowColor = '#00ffaa'; // Greenish glow
                    accentColor = '#ffaa00';
                    glowBlur = 21;
                    break;
                case 3: // Tank Mk.III - Sharper edges, integrated tech, Dual Machine Guns
                    hullColor = '#36404c';
                    treadColor = '#202830';
                    turretColor = '#455060';
                    barrelColor = '#6c7a8a';
                    reactiveArmorColor = '#8a9bb0';
                    glowColor = '#00aaff'; // Bluer glow
                    accentColor = '#ff00aa';
                    glowBlur = 24;
                    break;
                case 4: // Tank Mk.IV - Bulkier armor, advanced sensors, Missile Pods visible
                    hullColor = '#2a343e';
                    treadColor = '#182028';
                    turretColor = '#3a4550';
                    barrelColor = '#5c6a7a';
                    reactiveArmorColor = '#9cb0c4';
                    glowColor = '#aa00ff'; // Purple glow
                    accentColor = '#00ffff';
                    glowBlur = 27;
                    break;
                case 5: // Tank Mk.V - Sleek, predatory design, powerful barrel
                    hullColor = '#202a34';
                    treadColor = '#101820';
                    turretColor = '#303a45';
                    barrelColor = '#4c5a6a';
                    reactiveArmorColor = '#aec0d4';
                    glowColor = '#ff00ff'; // Magenta glow
                    accentColor = '#00ff00';
                    glowBlur = 30;
                    break;
                case 6: // Tank Mk.VI - Hyper-armored, heavier look, Additional Missile Pods
                    hullColor = '#1a222a';
                    treadColor = '#081018';
                    turretColor = '#252f3a';
                    barrelColor = '#3c4a5a';
                    reactiveArmorColor = '#c4d8ea';
                    glowColor = '#ffaa00'; // Orange glow
                    accentColor = '#00ff77';
                    glowBlur = 33;
                    break;
                case 7: // Tank Mk.VII - Highly futuristic, streamlined, subtle energy lines
                    hullColor = '#121820';
                    treadColor = '#040810';
                    turretColor = '#1a242c';
                    barrelColor = '#2c3a4a';
                    reactiveArmorColor = '#dae2ed';
                    glowColor = '#00ff00'; // Bright green glow
                    accentColor = '#ff00ff';
                    glowBlur = 36;
                    break;
                case 8: // Tank Mk.MAX - Ultimate design, most intricate details, intense glow
                    hullColor = '#0a1015';
                    treadColor = '#000005';
                    turretColor = '#101820';
                    barrelColor = '#1c2838';
                    reactiveArmorColor = '#ffffff'; // Near white armor
                    glowColor = '#ffff00'; // Golden glow
                    accentColor = '#ff0000';
                    glowBlur = 40;
                    break;
                default: // Fallback
                    hullColor = '#4e5a6b';
                    treadColor = '#323b47';
                    turretColor = '#5e6c7e';
                    barrelColor = '#8d99a9';
                    reactiveArmorColor = '#6c7a89';
                    glowColor = '#00ffff';
                    accentColor = '#aa00ff';
                    glowBlur = 15;
            }

            // Set global shadow properties for tank glow
            ctx.shadowBlur = glowBlur;
            ctx.shadowColor = glowColor;

            // --- Main Hull ---
            ctx.fillStyle = hullColor;
            ctx.beginPath();
            if (playerUpgradeLevel < 2) { // Basic angular hull
                ctx.moveTo(tankX, tankY + player.height * 0.4); // Rear bottom
                ctx.lineTo(tankX + player.width * 0.1, tankY + player.height * 0.2); // Rear top (slight angle)
                ctx.lineTo(tankX + player.width * 0.9, tankY + player.height * 0.2); // Front top (slight angle)
                ctx.lineTo(tankX + player.width, tankY + player.height * 0.4); // Front bottom
                ctx.lineTo(tankX + player.width, tankY + player.height); // Front ground level
                ctx.lineTo(tankX, tankY + player.height); // Rear ground level
            } else if (playerUpgradeLevel < 5) { // More defined, slightly armored hull
                ctx.moveTo(tankX, tankY + player.height * 0.5); // Rear bottom
                ctx.lineTo(tankX + player.width * 0.05, tankY + player.height * 0.3); // Rear top
                ctx.lineTo(tankX + player.width * 0.95, tankY + player.height * 0.3); // Front top
                ctx.lineTo(tankX + player.width, tankY + player.height * 0.5); // Front bottom
                ctx.lineTo(tankX + player.width, tankY + player.height); // Front ground level
                ctx.lineTo(tankX, tankY + player.height); // Rear ground level
            } else { // Futuristic, sleek hull
                ctx.moveTo(tankX - 5, tankY + player.height * 0.6); // Slightly extended rear bottom
                ctx.lineTo(tankX + player.width * 0.02, tankY + player.height * 0.25); // Sleek rear top
                ctx.lineTo(tankX + player.width * 0.98, tankY + player.height * 0.25); // Sleek front top
                ctx.lineTo(tankX + player.width + 5, tankY + player.height * 0.6); // Slightly extended front bottom
                ctx.lineTo(tankX + player.width + 5, tankY + player.height);
                ctx.lineTo(tankX - 5, tankY + player.height);
            }
            ctx.closePath();
            ctx.fill();

            // Hull top panel detail
            ctx.fillStyle = darkenColor(hullColor, -10);
            ctx.beginPath();
            if (playerUpgradeLevel < 3) {
                ctx.fillRect(tankX + player.width * 0.1, tankY + player.height * 0.2, player.width * 0.8, player.height * 0.05);
            } else {
                ctx.moveTo(tankX + player.width * 0.1, tankY + player.height * 0.2);
                ctx.lineTo(tankX + player.width * 0.9, tankY + player.height * 0.2);
                ctx.lineTo(tankX + player.width * 0.85, tankY + player.height * 0.25);
                ctx.lineTo(tankX + player.width * 0.15, tankY + player.height * 0.25);
                ctx.closePath();
                ctx.fill();
            }

            // --- Treads ---
            ctx.fillStyle = treadColor;
            const treadHeight = player.height * 0.25;
            ctx.beginPath();
            ctx.roundRect(tankX - 10, tankY + player.height * 0.7, player.width + 20, treadHeight, [8, 8, 8, 8]);
            ctx.fill();

            // Tread Detail Lines (animated)
            ctx.strokeStyle = darkenColor(treadColor, 15);
            ctx.lineWidth = 2;
            const treadLineSpacing = 15;
            const numLines = Math.ceil((player.width + 20) / treadLineSpacing);

            for (let i = 0; i < numLines; i++) {
                const lineX = tankX - 10 + (i * treadLineSpacing) + treadOffset;
                const wrappedX = lineX % (player.width + 20);
                if (wrappedX > -5 && wrappedX < player.width + 20) {
                    ctx.beginPath();
                    ctx.moveTo(tankX - 10 + wrappedX, tankY + player.height * 0.7);
                    ctx.lineTo(tankX - 10 + wrappedX, tankY + player.height * 0.7 + treadHeight);
                    ctx.stroke();
                }
            }
            // Inner tread detail
            if (playerUpgradeLevel >= 2) {
                ctx.fillStyle = darkenColor(treadColor, 20);
                ctx.beginPath();
                ctx.roundRect(tankX, tankY + player.height * 0.75, player.width, treadHeight * 0.6, [5,5,5,5]);
                ctx.fill();
            }


            // --- Turret (Modern AbramsX-inspired) ---
            ctx.fillStyle = turretColor;
            const turretCenterX = tankX + player.width * 0.6;
            const turretBaseY = tankY + player.height * 0.2;
            let currentTurretHeight = player.height * 0.45;
            let turretTopWidth;
            let turretBottomWidth;

            // AbramsX-like faceted turret body
            ctx.beginPath();
            if (playerUpgradeLevel < 2) { // Basic angular turret
                turretTopWidth = player.width * 0.4;
                turretBottomWidth = player.width * 0.55;
                ctx.moveTo(turretCenterX - turretBottomWidth / 2, turretBaseY);
                ctx.lineTo(turretCenterX - turretTopWidth / 2, turretBaseY - currentTurretHeight);
                ctx.lineTo(turretCenterX + turretTopWidth / 2, turretBaseY - currentTurretHeight);
                ctx.lineTo(turretCenterX + turretBottomWidth / 2, turretBaseY);
                ctx.lineTo(turretCenterX + turretBottomWidth * 0.4, turretBaseY + player.height * 0.05); // Rear slope
                ctx.lineTo(turretCenterX - turretBottomWidth * 0.4, turretBaseY + player.height * 0.05);
            } else if (playerUpgradeLevel < 5) { // More defined facets
                turretTopWidth = player.width * 0.45;
                turretBottomWidth = player.width * 0.6;
                ctx.moveTo(turretCenterX - turretBottomWidth / 2, turretBaseY);
                ctx.lineTo(turretCenterX - turretTopWidth / 2, turretBaseY - currentTurretHeight);
                ctx.lineTo(turretCenterX - turretTopWidth * 0.1, turretBaseY - currentTurretHeight * 1.1); // Slightly higher central top
                ctx.lineTo(turretCenterX + turretTopWidth * 0.1, turretBaseY - currentTurretHeight * 1.1);
                ctx.lineTo(turretCenterX + turretTopWidth / 2, turretBaseY - currentTurretHeight);
                ctx.lineTo(turretCenterX + turretBottomWidth / 2, turretBaseY);
                ctx.lineTo(turretCenterX + turretBottomWidth * 0.45, turretBaseY + player.height * 0.08); // More pronounced rear slope
                ctx.lineTo(turretCenterX - turretBottomWidth * 0.45, turretBaseY + player.height * 0.08);
            } else { // Highly angular, modern turret
                currentTurretHeight = player.height * 0.5; // Taller
                turretTopWidth = player.width * 0.5;
                turretBottomWidth = player.width * 0.7;
                ctx.moveTo(turretCenterX - turretBottomWidth / 2, turretBaseY + player.height * 0.03); // Slightly raised base
                ctx.lineTo(turretCenterX - turretTopWidth / 2, turretBaseY - currentTurretHeight + player.height * 0.03); // Top front left
                ctx.lineTo(turretCenterX - turretTopWidth * 0.1, turretBaseY - currentTurretHeight * 1.2 + player.height * 0.03); // Highest point
                ctx.lineTo(turretCenterX + turretTopWidth * 0.1, turretBaseY - currentTurretHeight * 1.2 + player.height * 0.03);
                ctx.lineTo(turretCenterX + turretTopWidth / 2, turretBaseY - currentTurretHeight + player.height * 0.03); // Top front right
                ctx.lineTo(turretCenterX + turretBottomWidth / 2, turretBaseY + player.height * 0.03); // Front bottom right
                ctx.lineTo(turretCenterX + turretBottomWidth * 0.4, turretBaseY + player.height * 0.12); // Deep rear slope
                ctx.lineTo(turretCenterX - turretBottomWidth * 0.4, turretBaseY + player.height * 0.12);
            }
            ctx.closePath();
            ctx.fill();

            // Turret top highlight/panels
            ctx.fillStyle = darkenColor(turretColor, -15);
            ctx.beginPath();
            if (playerUpgradeLevel >= 2) {
                ctx.moveTo(turretCenterX - turretTopWidth * 0.4, turretBaseY - currentTurretHeight * 0.9);
                ctx.lineTo(turretCenterX + turretTopWidth * 0.4, turretBaseY - currentTurretHeight * 0.9);
                ctx.lineTo(turretCenterX + turretTopWidth * 0.3, turretBaseY - currentTurretHeight * 0.8);
                ctx.lineTo(turretCenterX - turretTopWidth * 0.3, turretBaseY - currentTurretHeight * 0.8);
                ctx.closePath();
                ctx.fill();
            }

            // Commander's Station and Optics
            ctx.fillStyle = darkenColor(turretColor, 10);
            ctx.beginPath();
            ctx.ellipse(turretCenterX + turretTopWidth * 0.25, turretBaseY - currentTurretHeight * 0.7, 15, 10, 0, 0, Math.PI * 2); // Commander hatch area
            ctx.fill();
            ctx.fillStyle = glowColor; // Optical sensor glow
            ctx.beginPath();
            ctx.arc(turretCenterX + turretTopWidth * 0.25 + 5, turretBaseY - currentTurretHeight * 0.7, 4, 0, Math.PI * 2);
            ctx.fill();

            // Gunner's optics (smaller)
            ctx.fillStyle = darkenColor(turretColor, 10);
            ctx.beginPath();
            ctx.arc(turretCenterX - turretTopWidth * 0.2, turretBaseY - currentTurretHeight * 0.6, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = glowColor;
            ctx.beginPath();
            ctx.arc(turretCenterX - turretTopWidth * 0.2, turretBaseY - currentTurretHeight * 0.6, 2, 0, Math.PI * 2);
            ctx.fill();


            // --- Main Cannon Barrel ---
            ctx.fillStyle = barrelColor;
            const barrelY = tankY + player.height * 0.05; // Adjust vertical position
            let barrelHeight = 14;
            let muzzleBrakeWidth = 20;

            if (playerUpgradeLevel >= 4) { // Mk.IV+: thicker barrel
                barrelHeight = 18;
                muzzleBrakeWidth = 25;
            }
            if (playerUpgradeLevel >= 7) { // Mk.VII+: even thicker, more complex
                barrelHeight = 22;
                muzzleBrakeWidth = 30;
            }

            const barrelOriginX = turretCenterX + turretTopWidth * 0.2; // Adjusted to be centered on right side of turret
            ctx.fillRect(barrelOriginX, barrelY - barrelHeight / 2, player.barrelLength, barrelHeight);

            // Muzzle Brake - more detailed with level
            ctx.fillStyle = darkenColor(barrelColor, 20);
            if (playerUpgradeLevel < 3) {
                ctx.fillRect(barrelOriginX + player.barrelLength, barrelY - barrelHeight / 2 - 3, muzzleBrakeWidth, barrelHeight + 6);
            } else {
                ctx.beginPath();
                ctx.moveTo(barrelOriginX + player.barrelLength, barrelY - barrelHeight / 2 - 5);
                ctx.lineTo(barrelOriginX + player.barrelLength + muzzleBrakeWidth, barrelY - barrelHeight / 2 - 5);
                ctx.lineTo(barrelOriginX + player.barrelLength + muzzleBrakeWidth * 0.8, barrelY - barrelHeight / 2 + barrelHeight + 5);
                ctx.lineTo(barrelOriginX + player.barrelLength, barrelY - barrelHeight / 2 + barrelHeight + 5);
                ctx.closePath();
                ctx.fill();

                // Muzzle brake internal detail
                ctx.fillStyle = darkenColor(barrelColor, 30);
                ctx.fillRect(barrelOriginX + player.barrelLength + 5, barrelY - barrelHeight / 2, muzzleBrakeWidth - 10, barrelHeight);
            }

            // --- Additional Guns / Weapon Systems ---

            // Secondary Machine Gun (appears at Mk.I)
            if (playerUpgradeLevel >= 1) {
                ctx.fillStyle = darkenColor(turretColor, 20);
                // Mount
                ctx.beginPath();
                ctx.arc(turretCenterX + turretTopWidth * 0.4, turretBaseY - currentTurretHeight * 0.5, 6, 0, Math.PI * 2);
                ctx.fill();
                // Barrel
                ctx.fillRect(turretCenterX + turretTopWidth * 0.4 + 5, turretBaseY - currentTurretHeight * 0.5 - 2, 18, 4);
                // Sight
                ctx.fillStyle = '#000';
                ctx.fillRect(turretCenterX + turretTopWidth * 0.4 + 10, turretBaseY - currentTurretHeight * 0.5 - 4, 5, 2);
            }

            // Dual Machine Guns (appears at Mk.III)
            if (playerUpgradeLevel >= 3) {
                ctx.fillStyle = darkenColor(turretColor, 20);
                // Left gun
                ctx.beginPath();
                ctx.arc(turretCenterX - turretTopWidth * 0.35, turretBaseY - currentTurretHeight * 0.4, 7, 0, Math.PI * 2); // Mount
                ctx.fill();
                ctx.fillRect(turretCenterX - turretTopWidth * 0.35 + 5, turretBaseY - currentTurretHeight * 0.4 - 3, 20, 6); // Barrel

                // Right gun (adjust position to avoid overlap with commander's optics)
                ctx.beginPath();
                ctx.arc(turretCenterX + turretTopWidth * 0.1, turretBaseY - currentTurretHeight * 0.4, 7, 0, Math.PI * 2); // Mount
                ctx.fill();
                ctx.fillRect(turretCenterX + turretTopWidth * 0.1 + 5, turretBaseY - currentTurretHeight * 0.4 - 3, 20, 6); // Barrel
            }

            // Missile Pods (appears at Mk.IV)
            if (playerUpgradeLevel >= 4) {
                ctx.fillStyle = darkenColor(hullColor, 15);
                const podWidth = 30;
                const podHeight = 20;
                // Left pod (more integrated into hull side)
                ctx.fillRect(tankX + player.width * 0.05, tankY + player.height * 0.35, podWidth, podHeight);
                // Right pod
                ctx.fillRect(tankX + player.width - podWidth - player.width * 0.05, tankY + player.height * 0.35, podWidth, podHeight);
                
                // Missile openings
                ctx.fillStyle = '#111';
                ctx.fillRect(tankX + player.width * 0.05 + 5, tankY + player.height * 0.35 + 4, 8, 12);
                ctx.fillRect(tankX + player.width * 0.05 + 18, tankY + player.height * 0.35 + 4, 8, 12);
                ctx.fillRect(tankX + player.width - podWidth - player.width * 0.05 + 5, tankY + player.height * 0.35 + 4, 8, 12);
                ctx.fillRect(tankX + player.width - podWidth - player.width * 0.05 + 18, tankY + player.height * 0.35 + 4, 8, 12);
            }

            // Additional missile pods or rocket launchers (appears at Mk.VI)
            if (playerUpgradeLevel >= 6) {
                ctx.fillStyle = darkenColor(turretColor, 10);
                const largePodWidth = 40;
                const largePodHeight = 25;

                // Larger pod on top of turret (positioned on rear corners of the flat top)
                ctx.fillRect(turretCenterX - turretTopWidth / 2 + 10, turretBaseY - currentTurretHeight * 0.8 - 10, largePodWidth, largePodHeight);
                ctx.fillRect(turretCenterX + turretTopWidth / 2 - largePodWidth - 10, turretBaseY - currentTurretHeight * 0.8 - 10, largePodWidth, largePodHeight);

                // Missile openings for larger pods
                ctx.fillStyle = '#111';
                ctx.fillRect(turretCenterX - turretTopWidth / 2 + 18, turretBaseY - currentTurretHeight * 0.8 - 5, 8, 15);
                ctx.fillRect(turretCenterX - turretTopWidth / 2 + 34, turretBaseY - currentTurretHeight * 0.8 - 5, 8, 15);
                ctx.fillRect(turretCenterX + turretTopWidth / 2 - largePodWidth, turretBaseY - currentTurretHeight * 0.8 - 5, 8, 15);
                ctx.fillRect(turretCenterX + turretTopWidth / 2 - largePodWidth + 16, turretBaseY - currentTurretHeight * 0.8 - 5, 8, 15);
            }

            // --- Smoke Dischargers (small cylinders on turret side) ---
            ctx.fillStyle = '#3a4a50';
            ctx.beginPath();
            ctx.arc(turretCenterX - turretBottomWidth * 0.4, turretBaseY - currentTurretHeight * 0.3, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(turretCenterX - turretBottomWidth * 0.3, turretBaseY - currentTurretHeight * 0.25, 5, 0, Math.PI * 2);
            ctx.fill();


            // --- Reactive Armor Blocks ---
            ctx.fillStyle = reactiveArmorColor;
            // Base blocks
            ctx.fillRect(tankX + player.width * 0.15, tankY + player.height * 0.45, 20, 15);
            ctx.fillRect(tankX + player.width * 0.4, tankY + player.height * 0.5, 20, 15);

            if (playerUpgradeLevel >= 2) { // Mk.II: More armor blocks, slightly larger
                ctx.fillRect(tankX + player.width * 0.65, tankY + player.height * 0.45, 25, 18);
                ctx.fillRect(tankX + player.width * 0.25, tankY + player.height * 0.55, 18, 25); // Vertical block
            }
            if (playerUpgradeLevel >= 4) { // Mk.IV: Even more armor, layered look
                ctx.fillRect(tankX + player.width * 0.55, tankY + player.height * 0.6, 18, 25);
                ctx.fillRect(tankX + player.width * 0.8, tankY + player.height * 0.5, 18, 25);
                ctx.fillRect(tankX + player.width * 0.05, tankY + player.height * 0.48, 10, 10); // Small front block
                // More complex layering
                ctx.fillStyle = darkenColor(reactiveArmorColor, -10);
                ctx.fillRect(tankX + player.width * 0.66, tankY + player.height * 0.43, 20, 15); // Layered on top
            }
            if (playerUpgradeLevel >= 6) { // Mk.VI: Side Skirts (larger armor) and integrated look
                ctx.fillRect(tankX - 15, tankY + player.height * 0.6, 20, player.height * 0.4); // Front skirt
                ctx.fillRect(tankX + player.width - 5, tankY + player.height * 0.6, 20, player.height * 0.4); // Rear skirt
                // Connecting piece for side skirts
                ctx.fillStyle = darkenColor(reactiveArmorColor, 10);
                ctx.fillRect(tankX, tankY + player.height * 0.7, player.width, 10);
            }
            if (playerUpgradeLevel >= 7) { // Mk.VII: Turret reactive armor
                 ctx.fillRect(turretCenterX - turretTopWidth * 0.25, turretBaseY - currentTurretHeight + 10, 10, 10);
                 ctx.fillRect(turretCenterX + turretTopWidth * 0.25 - 10, turretBaseY - currentTurretHeight + 10, 10, 10);
                 // Side turret armor
                 ctx.fillRect(turretCenterX - turretBottomWidth * 0.5 - 5, turretBaseY + 5, 8, currentTurretHeight - 10);
                 ctx.fillRect(turretCenterX + turretBottomWidth * 0.5 - 3, turretBaseY + 5, 8, currentTurretHeight - 10);
            }
            if (playerUpgradeLevel >= 8) { // Mk.MAX: Glowing energy vents on armor
                ctx.fillStyle = accentColor;
                ctx.shadowBlur = glowBlur * 0.8;
                ctx.shadowColor = accentColor;
                ctx.fillRect(tankX + player.width * 0.3, tankY + player.height * 0.65, 10, 5);
                ctx.fillRect(tankX + player.width * 0.7, tankY + player.height * 0.65, 10, 5);
                // Add more energy lines to hull
                ctx.fillRect(tankX + player.width * 0.2, tankY + player.height * 0.3, 3, 20);
                ctx.fillRect(tankX + player.width * 0.78, tankY + player.height * 0.3, 3, 20);

                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }


            // Reset shadow
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
        }

        /**
         * Draws a detailed victim character.
         */
        function drawVictim(victim) {
            const victimX = victim.x;
            const victimY = victim.y;
            const headRadius = VICTIM_HEAD_RADIUS;
            const bodyWidth = VICTIM_BODY_WIDTH;
            const bodyHeight = VICTIM_BODY_HEIGHT;

            ctx.fillStyle = '#fbc531'; // Skin tone

            // Head (more detailed circle)
            ctx.beginPath();
            ctx.arc(victimX + headRadius, victimY + headRadius, headRadius, 0, Math.PI * 2);
            ctx.fill();

            // Body (slightly tapered)
            ctx.beginPath();
            ctx.moveTo(victimX, victimY + headRadius * 2);
            ctx.lineTo(victimX + bodyWidth, victimY + headRadius * 2);
            ctx.lineTo(victimX + bodyWidth * 0.9, victimY + headRadius * 2 + bodyHeight);
            ctx.lineTo(victimX + bodyWidth * 0.1, victimY + headRadius * 2 + bodyHeight);
            ctx.closePath();
            ctx.fill();

            // Clothing - more defined
            ctx.fillStyle = '#3498db'; // Shirt
            ctx.fillRect(victimX, victimY + headRadius * 2, bodyWidth, bodyHeight * 0.6);
            ctx.fillStyle = '#2c3e50'; // Pants
            ctx.fillRect(victimX, victimY + headRadius * 2 + bodyHeight * 0.6, bodyWidth, bodyHeight * 0.4);

            // Arms (slightly bent)
            ctx.fillStyle = '#fbc531';
            ctx.fillRect(victimX - 5, victimY + headRadius * 2 + 5, 5, 20); // Upper left
            ctx.fillRect(victimX + bodyWidth, victimY + headRadius * 2 + 5, 5, 20); // Upper right
            ctx.fillRect(victimX - 8, victimY + headRadius * 2 + 20, 5, 10); // Lower left
            ctx.fillRect(victimX + bodyWidth + 3, victimY + headRadius * 2 + 20, 5, 10); // Lower right

            // Legs (slightly bent)
            ctx.fillStyle = '#fbc531';
            ctx.fillRect(victimX + 5, victimY + headRadius * 2 + bodyHeight, 5, 25); // Left leg
            ctx.fillRect(victimX + bodyWidth - 10, victimY + headRadius * 2 + bodyHeight, 5, 25); // Right leg

            // Hair/Facial features - more expressive
            ctx.fillStyle = '#000'; // Eyes
            ctx.beginPath();
            ctx.arc(victimX + headRadius - 3, victimY + headRadius * 1.2, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(victimX + headRadius + 3, victimY + headRadius * 1.2, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000'; // Mouth
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(victimX + headRadius, victimY + headRadius * 1.5 + 2, 3, 0, Math.PI, false);
            ctx.stroke();

            // Health bar for victim
            drawHealthBar(victimX, victimY - 15, bodyWidth, 5, victim.health, victim.maxHealth, '#e74c3c');
        }

        /**
         * Draws a detailed zombie with appearance variations based on tier.
         */
        function drawZombie(zombie) {
            const zombieX = zombie.x;
            const zombieY = zombie.y;
            let bodyColor, headColor, exposedColor, eyeColor, clothingColor;

            if (zombie.type === 'zombieTank') {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00ff00'; // Greenish glow for zombie tank
                ctx.fillStyle = '#223322'; // Dark green/brown base
                ctx.fillRect(zombieX, zombieY + ZOMBIE_TANK_HEIGHT * 0.4, ZOMBIE_TANK_WIDTH, ZOMBIE_TANK_HEIGHT * 0.6); // Hull
                ctx.fillStyle = '#334433';
                ctx.fillRect(zombieX + ZOMBIE_TANK_WIDTH * 0.1, zombieY, ZOMBIE_TANK_WIDTH * 0.6, ZOMBIE_TANK_HEIGHT * 0.5); // Turret
                ctx.fillStyle = '#111'; // Treads
                ctx.fillRect(zombieX - 10, zombieY + ZOMBIE_TANK_HEIGHT * 0.8, ZOMBIE_TANK_WIDTH + 20, 15);
                
                // Zombie tank barrel (broken, rusted)
                ctx.fillStyle = '#554433';
                ctx.fillRect(zombieX + ZOMBIE_TANK_WIDTH * 0.6, zombieY + ZOMBIE_TANK_HEIGHT * 0.2, ZOMBIE_TANK_WIDTH * 0.4, 10);
                ctx.shadowBlur = 0; // Reset shadow

                // Glowing zombie eyes on tank
                ctx.fillStyle = '#ff0000';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff0000';
                ctx.beginPath();
                ctx.arc(zombieX + ZOMBIE_TANK_WIDTH * 0.3, zombieY + ZOMBIE_TANK_HEIGHT * 0.2, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(zombieX + ZOMBIE_TANK_WIDTH * 0.7, zombieY + ZOMBIE_TANK_HEIGHT * 0.2, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';

                // Rusted patches
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(zombieX + ZOMBIE_TANK_WIDTH * 0.2, zombieY + ZOMBIE_TANK_HEIGHT * 0.5, 15, 10);
                ctx.fillRect(zombieX + ZOMBIE_TANK_WIDTH * 0.7, zombieY + ZOMBIE_TANK_HEIGHT * 0.6, 10, 15);

            } else {
                // Regular Zombie Drawing
                switch (currentZombieTier) {
                    case 0: // Shambler (Basic)
                        bodyColor = '#4f5e3e';
                        headColor = '#6e8b4e';
                        exposedColor = '#a0522d';
                        eyeColor = '#ff0000';
                        clothingColor = '#2f4f4f';
                        break;
                    case 1: // Groaner (More emaciated, sickly color)
                        bodyColor = '#3e524f'; // Grayer green
                        headColor = '#5e726b';
                        exposedColor = '#804220';
                        eyeColor = '#ff4500'; // Orange-red
                        clothingColor = '#253535'; // Darker clothes
                        ctx.fillStyle = darkenColor(bodyColor, 10);
                        ctx.fillRect(zombieX + ZOMBIE_WIDTH * 0.3, zombieY + ZOMBIE_HEIGHT * 0.4, 5, 20); // Ribs
                        ctx.fillRect(zombieX + ZOMBIE_WIDTH * 0.6, zombieY + ZOMBIE_HEIGHT * 0.4, 5, 20); // Ribs
                        break;
                    case 2: // Fleshpound (Bulky, more rotten, glowing elements)
                        bodyColor = '#5c3a2f'; // Brownish-red, very rotten
                        headColor = '#7d4a3e';
                        exposedColor = '#c06030'; // More vibrant exposed flesh
                        eyeColor = '#00ff00'; // Green glowing eyes
                        clothingColor = '#1a1a1a'; // Almost black rags
                        ctx.fillStyle = darkenColor(bodyColor, -15); // Muscle definition
                        ctx.beginPath();
                        ctx.ellipse(zombieX + ZOMBIE_WIDTH * 0.5, zombieY + ZOMBIE_HEIGHT * 0.5, ZOMBIE_WIDTH * 0.4, ZOMBIE_HEIGHT * 0.2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 12; // Stronger eye glow
                        break;
                    case 3: // Crawler (Lower to ground, faster, distorted)
                        bodyColor = '#333333'; // Almost black, stealthy
                        headColor = '#4a4a4a';
                        exposedColor = '#606060';
                        eyeColor = '#ffff00'; // Yellow eyes
                        clothingColor = '#101010'; // Blend with shadows
                        ctx.fillStyle = bodyColor;
                        ctx.fillRect(zombieX, zombieY + ZOMBIE_HEIGHT * 0.6, ZOMBIE_WIDTH * 1.2, ZOMBIE_HEIGHT * 0.4); // Wider, lower body
                        ctx.fillStyle = headColor;
                        ctx.beginPath();
                        ctx.arc(zombieX + ZOMBIE_WIDTH * 0.6, zombieY + ZOMBIE_HEIGHT * 0.6, ZOMBIE_WIDTH * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 10;
                        break;
                    default: // Fallback to Shambler
                        bodyColor = '#4f5e3e';
                        headColor = '#6e8b4e';
                        exposedColor = '#a0522d';
                        eyeColor = '#ff0000';
                        clothingColor = '#2f4f4f';
                }

                // Body
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.moveTo(zombieX, zombieY + ZOMBIE_HEIGHT * 0.8);
                ctx.quadraticCurveTo(zombieX - 10, zombieY + ZOMBIE_HEIGHT * 0.4, zombieX + ZOMBIE_WIDTH * 0.2, zombieY + ZOMBIE_HEIGHT * 0.3);
                ctx.lineTo(zombieX + ZOMBIE_WIDTH * 0.8, zombieY + ZOMBIE_HEIGHT * 0.2);
                ctx.quadraticCurveTo(zombieX + ZOMBIE_WIDTH + 10, zombieY + ZOMBIE_HEIGHT * 0.4, zombieX + ZOMBIE_WIDTH, zombieY + ZOMBIE_HEIGHT * 0.7);
                ctx.lineTo(zombieX + ZOMBIE_WIDTH * 0.8, zombieY + ZOMBIE_HEIGHT);
                ctx.lineTo(zombieX + ZOMBIE_WIDTH * 0.2, zombieY + ZOMBIE_HEIGHT);
                ctx.closePath();
                ctx.fill();

                // Head
                ctx.fillStyle = headColor;
                ctx.beginPath();
                ctx.ellipse(zombieX + ZOMBIE_WIDTH * 0.6, zombieY + ZOMBIE_HEIGHT * 0.2, ZOMBIE_WIDTH * 0.25, ZOMBIE_HEIGHT * 0.15, -Math.PI / 8, 0, Math.PI * 2);
                ctx.fill();

                // Exposed brain/skull
                ctx.fillStyle = exposedColor;
                ctx.beginPath();
                ctx.arc(zombieX + ZOMBIE_WIDTH * 0.65, zombieY + ZOMBIE_HEIGHT * 0.15, 7, 0, Math.PI * 2);
                ctx.fill();

                // Jaw/Mouth area (torn)
                ctx.fillStyle = darkenColor(exposedColor, 30);
                ctx.fillRect(zombieX + ZOMBIE_WIDTH * 0.55, zombieY + ZOMBIE_HEIGHT * 0.28, ZOMBIE_WIDTH * 0.2, 5);

                // Eyes - glowing
                ctx.fillStyle = eyeColor;
                ctx.shadowBlur = 10;
                ctx.shadowColor = eyeColor;
                ctx.beginPath();
                ctx.arc(zombieX + ZOMBIE_WIDTH * 0.55, zombieY + ZOMBIE_HEIGHT * 0.2, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(zombieX + ZOMBIE_WIDTH * 0.65, zombieY + ZOMBIE_HEIGHT * 0.22, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';

                // Tattered clothing
                ctx.fillStyle = clothingColor;
                ctx.fillRect(zombieX + ZOMBIE_WIDTH * 0.1, zombieY + ZOMBIE_HEIGHT * 0.4, ZOMBIE_WIDTH * 0.8, ZOMBIE_HEIGHT * 0.3);
                ctx.strokeStyle = darkenColor(clothingColor, 20);
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(zombieX + ZOMBIE_WIDTH * 0.2, zombieY + ZOMBIE_HEIGHT * 0.7);
                ctx.lineTo(zombieX + ZOMBIE_WIDTH * 0.1, zombieY + ZOMBIE_HEIGHT * 0.75);
                ctx.lineTo(zombieX + ZOMBIE_WIDTH * 0.3, zombieY + ZOMBIE_HEIGHT * 0.78);
                ctx.stroke();

                // Arms
                ctx.fillStyle = bodyColor;
                ctx.fillRect(zombieX + ZOMBIE_WIDTH * 0.1, zombieY + ZOMBIE_HEIGHT * 0.3, 8, 35);
                ctx.fillRect(zombieX + ZOMBIE_WIDTH * 0.85, zombieY + ZOMBIE_HEIGHT * 0.3, 8, 35);

                // Hands/Claws
                ctx.fillStyle = exposedColor;
                ctx.beginPath();
                ctx.moveTo(zombieX + ZOMBIE_WIDTH * 0.1, zombieY + ZOMBIE_HEIGHT * 0.3 + 35);
                ctx.lineTo(zombieX + ZOMBIE_WIDTH * 0.1 - 5, zombieY + ZOMBIE_HEIGHT * 0.3 + 45);
                ctx.lineTo(zombieX + ZOMBIE_WIDTH * 0.1 + 5, zombieY + ZOMBIE_HEIGHT * 0.3 + 45);
                ctx.closePath();
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(zombieX + ZOMBIE_WIDTH * 0.85, zombieY + ZOMBIE_HEIGHT * 0.3 + 35);
                ctx.lineTo(zombieX + ZOMBIE_WIDTH * 0.85 - 5, zombieY + ZOMBIE_HEIGHT * 0.3 + 45);
                ctx.lineTo(zombieX + ZOMBIE_WIDTH * 0.85 + 5, zombieY + ZOMBIE_HEIGHT * 0.3 + 45);
                ctx.closePath();
                ctx.fill();

                // Legs
                ctx.fillStyle = bodyColor;
                ctx.fillRect(zombieX + ZOMBIE_WIDTH * 0.3, zombieY + ZOMBIE_HEIGHT * 0.7, 10, 20);
                ctx.fillRect(zombieX + ZOMBIE_WIDTH * 0.6, zombieY + ZOMBIE_HEIGHT * 0.7, 10, 20);
                ctx.fillRect(zombieX + ZOMBIE_WIDTH * 0.25, zombieY + ZOMBIE_HEIGHT * 0.9, 15, 5);
                ctx.fillRect(zombieX + ZOMBIE_WIDTH * 0.55, zombieY + ZOMBIE_HEIGHT * 0.9, 15, 5);
            }
            // Health bar for zombie (or zombie tank)
            drawHealthBar(zombieX, zombieY - 10, zombie.width, 5, zombie.health, zombie.maxHealth, '#f39c12');
        }


        /**
         * Draws different types of projectiles (bullets, lasers, missiles).
         */
        function drawProjectile(p) {
            if (p.type === 'bullet') {
                const rocketWidth = 10;
                const rocketHeight = 6;

                ctx.fillStyle = p.color;
                ctx.fillRect(p.x - rocketWidth / 2, p.y - rocketHeight / 2, rocketWidth, rocketHeight);

                ctx.beginPath();
                ctx.moveTo(p.x + rocketWidth / 2, p.y - rocketHeight / 2);
                ctx.lineTo(p.x + rocketWidth / 2 + 5, p.y);
                ctx.lineTo(p.x + rocketWidth / 2, p.y + rocketHeight / 2);
                ctx.closePath();
                ctx.fill();

                const exhaustLength = 20;
                let exhaustGradient = ctx.createLinearGradient(p.x - rocketWidth / 2 - exhaustLength, p.y, p.x - rocketWidth / 2, p.y);
                exhaustGradient.addColorStop(0, 'rgba(255, 165, 0, 0.8)');
                exhaustGradient.addColorStop(0.5, 'rgba(255, 255, 0, 0.5)');
                exhaustGradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');
                ctx.fillStyle = exhaustGradient;
                ctx.fillRect(p.x - rocketWidth / 2 - exhaustLength, p.y - rocketHeight / 2 - 2, exhaustLength, rocketHeight + 4);

                ctx.shadowBlur = 8;
                ctx.shadowColor = p.color;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x - rocketWidth / 2, p.y - rocketHeight / 2, rocketWidth, rocketHeight);
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';

            } else if (p.type === 'laser') {
                ctx.fillStyle = p.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = p.color;
                ctx.fillRect(p.x, p.y - p.height / 2, p.width, p.height);
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            } else if (p.type === 'missile') {
                // Missile body
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.moveTo(p.x - p.width / 2, p.y - p.height / 2);
                ctx.lineTo(p.x + p.width / 2, p.y);
                ctx.lineTo(p.x - p.width / 2, p.y + p.height / 2);
                ctx.closePath();
                ctx.fill();

                // Missile tip
                ctx.fillStyle = darkenColor(p.color, -20);
                ctx.beginPath();
                ctx.moveTo(p.x + p.width / 2, p.y);
                ctx.lineTo(p.x + p.width / 2 + 5, p.y - p.height / 4);
                ctx.lineTo(p.x + p.width / 2 + 5, p.y + p.height / 4);
                ctx.closePath();
                ctx.fill();

                // Missile exhaust
                const exhaustLength = 15;
                let exhaustGradient = ctx.createLinearGradient(p.x - p.width / 2 - exhaustLength, p.y, p.x - p.width / 2, p.y);
                exhaustGradient.addColorStop(0, 'rgba(255, 0, 0, 0.8)');
                exhaustGradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.5)');
                exhaustGradient.addColorStop(1, 'rgba(255, 200, 0, 0.1)');
                ctx.fillStyle = exhaustGradient;
                ctx.fillRect(p.x - p.width / 2 - exhaustLength, p.y - p.height / 2, exhaustLength, p.height);

                ctx.shadowBlur = 12;
                ctx.shadowColor = p.color;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.moveTo(p.x - p.width / 2, p.y - p.height / 2);
                ctx.lineTo(p.x + p.width / 2, p.y);
                ctx.lineTo(p.x - p.width / 2, p.y + p.height / 2);
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        }

        /**
         * Draws all active blood particles.
         */
        function drawBloodParticles() {
            bloodParticles.forEach(p => {
                ctx.fillStyle = p.color;
                const alpha = p.life / BLOOD_PARTICLE_LIFESPAN;
                ctx.globalAlpha = alpha;
                ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
                ctx.globalAlpha = 1;
            });
        }

        /**
         * Draws explosion particles.
         */
        function drawExplosionParticles() {
            explosions.forEach(p => {
                ctx.fillStyle = p.color;
                const alpha = p.life / EXPLOSION_PARTICLE_LIFESPAN;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });
        }

        /**
         * Handles drawing all game elements.
         */
        function draw() {
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            drawBackground();

            drawPlayer();
            victims.forEach(drawVictim);
            zombies.forEach(drawZombie); // Handles both regular and tank zombies
            projectiles.forEach(drawProjectile); // Use projectiles array
            drawBloodParticles();
            drawExplosionParticles(); // Draw explosions
        }

        // --- Firebase Functions ---

        /**
         * Fetches the best score from Firestore.
         */
        async function getHighScore() {
            if (!isFirebaseReady || !userId) {
                console.log("Firebase not ready or userId not available for high score fetch.");
                return;
            }
            try {
                const highScoresRef = doc(db, 'artifacts', appId, 'users', userId, 'highscores', 'zombieHunterHighScore');
                const docSnap = await getDoc(highScoresRef);
                if (docSnap.exists()) {
                    bestScore = docSnap.data().value || 0;
                } else {
                    bestScore = 0;
                }
                bestScoreDisplay.textContent = `Best Score: ${bestScore}`;
            } catch (error) {
                console.error("Error getting high score:", error);
            }
        }

        /**
         * Sets (updates) the best score in Firestore.
         */
        async function setHighScore(newScore) {
            if (!isFirebaseReady || !userId) {
                console.log("Firebase not ready or userId not available for high score set.");
                return;
            }
            try {
                const highScoresRef = doc(db, 'artifacts', appId, 'users', userId, 'highscores', 'zombieHunterHighScore');
                await setDoc(highScoresRef, { value: newScore }, { merge: true });
                bestScore = newScore;
                bestScoreDisplay.textContent = `Best Score: ${bestScore}`;
            } catch (error) {
                console.error("Error setting high score:", error);
            }
        }

        // --- Game Logic Functions ---

        /**
         * Resets all game variables to their initial state.
         */
        function resetGame() {
            projectiles = []; // Reset projectiles
            zombies = [];
            bloodParticles = [];
            explosions = []; // Reset explosions
            score = 0;
            currentWave = 1;
            zombieSpeed = ZOMBIE_INITIAL_SPEED;
            zombieSpawnRate = ZOMBIE_SPAWN_INTERVAL;
            player.health = MAX_TANK_HEALTH;
            playerUpgradeLevel = 0; // Reset tank upgrade level
            currentZombieTier = 0; // Reset zombie tier
            currentBackgroundThemeIndex = 0; // Reset background theme
            
            // Apply initial tank stats for primary weapon
            player.barrelLength = TANK_UPGRADE_LEVELS[playerUpgradeLevel].barrelLength;
            BULLET_SPEED = TANK_UPGRADE_LEVELS[playerUpgradeLevel].bulletSpeed;
            BULLET_DAMAGE = TANK_UPGRADE_LEVELS[playerUpgradeLevel].bulletDamage;
            FIRE_RATE_COOLDOWN = TANK_UPGRADE_LEVELS[playerUpgradeLevel].fireRate;

            player.canFirePrimary = true;
            player.currentPrimaryCooldown = 0;
            player.canFireLaser = true;
            player.currentLaserCooldown = 0;
            player.canFireMissile = true;
            player.currentMissileCooldown = 0;

            upgradeAvailable = false;
            tankUpgraded = false;
            
            upgradeButton.style.display = 'none';
            // Ensure UPGRADE_SCORE_THRESHOLDS[playerUpgradeLevel] is valid before access
            if (playerUpgradeLevel < UPGRADE_SCORE_THRESHOLDS.length) {
                upgradeButton.textContent = `Upgrade Tank (${UPGRADE_SCORE_THRESHOLDS[playerUpgradeLevel]} pts)`;
            } else {
                upgradeButton.textContent = `Tank MAX!`; // Or some other indication if already maxed out
            }
            
            treadOffset = 0;

            // Initialize victims
            victims = [];
            for (let i = 0; i < VICTIM_INITIAL_COUNT; i++) {
                victims.push({
                    x: DEFENSE_LINE_X - (VICTIM_WIDTH * 1.5 * (i + 1)), // Position victims behind defense line
                    y: VICTIM_Y,
                    width: VICTIM_WIDTH,
                    height: VICTIM_HEIGHT,
                    health: 100,
                    maxHealth: 100,
                    isAlive: true
                });
            }

            gameOver = false;
            gameRunning = false;
            lastZombieSpawnTime = 0;
            player.x = GAME_WIDTH / 4;
            player.y = STREET_MIN_Y_DRAW + (STREET_MAX_Y_DRAW - STREET_MIN_Y_DRAW) / 2 - TANK_HEIGHT / 2;

            scoreDisplay.textContent = `Score: ${score}`;
            bestScoreDisplay.textContent = `Best Score: ${bestScore}`;
            tankHealthDisplay.textContent = `Tank HP: ${player.health}`;
            victimCountDisplay.textContent = `Victims: ${victims.filter(v => v.isAlive).length}`;
            waveDisplay.textContent = `Wave: ${currentWave}`;
            gameOverScreen.style.display = 'none';
            startButton.style.display = 'block';
            restartButton.style.display = 'none';

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            draw();
        }

        /**
         * Fires a primary bullet.
         */
        function firePrimaryBullet() {
            if (!gameRunning || gameOver || !player.canFirePrimary) return;

            projectiles.push({
                x: player.x + player.barrelLength / 2, // From tank barrel tip
                y: player.y + (player.height * 0.05), // Align with barrel
                width: 10, // For drawing
                height: 6, // For drawing
                radius: BULLET_RADIUS, // For collision
                color: '#ffff00',
                speed: BULLET_SPEED,
                damage: BULLET_DAMAGE,
                type: 'bullet'
            });
            player.canFirePrimary = false;
            player.currentPrimaryCooldown = FIRE_RATE_COOLDOWN;
        }

        /**
         * Fires a laser beam from machine guns.
         */
        function fireLaser() {
            if (!gameRunning || gameOver || !player.canFireLaser || !TANK_UPGRADE_LEVELS[playerUpgradeLevel].laserEnabled) return;

            // Find the closest zombie to target
            let targetZombie = null;
            let minDistance = Infinity;

            for (const zombie of zombies) {
                const dist = Math.abs(zombie.x - (player.x + player.barrelLength / 2));
                if (dist < minDistance) {
                    minDistance = dist;
                    targetZombie = zombie;
                }
            }

            if (!targetZombie) {
                // console.log("No zombie target found for laser."); // Commented out to reduce console spam
                return; // Exit if no target
            }

            // Fire from the first machine gun (top right of turret)
            projectiles.push({
                x: player.x + player.width * 0.75 + 18, // End of barrel
                y: player.y + player.height * 0.1, // Alignment
                width: LASER_WIDTH,
                height: LASER_HEIGHT,
                color: '#00ccff', // Blue laser
                speed: LASER_SPEED,
                damage: LASER_DAMAGE,
                type: 'laser'
            });

            // If dual machine guns are enabled (Mk.III and above)
            if (playerUpgradeLevel >= 3) {
                 projectiles.push({
                    x: player.x + player.width * 0.8 + 20, // End of barrel for right gun
                    y: player.y + player.height * 0.25, // Alignment for right gun
                    width: LASER_WIDTH,
                    height: LASER_HEIGHT,
                    color: '#00ccff',
                    speed: LASER_SPEED,
                    damage: LASER_DAMAGE,
                    type: 'laser'
                });
                projectiles.push({
                    x: player.x + player.width * 0.25 + 20, // End of barrel for left gun
                    y: player.y + player.height * 0.25, // Alignment for left gun
                    width: LASER_WIDTH,
                    height: LASER_HEIGHT,
                    color: '#00ccff',
                    speed: LASER_SPEED,
                    damage: LASER_DAMAGE,
                    type: 'laser'
                });
            }

            player.canFireLaser = false;
            player.currentLaserCooldown = LASER_COOLDOWN;
        }

        /**
         * Fires a missile from missile pods.
         */
        function fireMissile() {
            if (!gameRunning || gameOver || !player.canFireMissile || !TANK_UPGRADE_LEVELS[playerUpgradeLevel].missileEnabled) return;

            // Find the closest zombie to target
            let targetZombie = null;
            let minDistance = Infinity;

            for (const zombie of zombies) {
                const dist = Math.abs(zombie.x - (player.x + player.barrelLength / 2));
                if (dist < minDistance) {
                    minDistance = dist;
                    targetZombie = zombie;
                }
            }

            if (!targetZombie) {
                // console.log("No zombie target found for missile."); // Commented out to reduce console spam
                return; // Exit if no target
            }

            // Calculate launch points from the missile pods
            const launchPoints = [];
            if (playerUpgradeLevel >= 4) { // Main side pods
                launchPoints.push({
                    x: player.x + player.width * 0.05 + 30,
                    y: player.y + player.height * 0.35 + MISSILE_HEIGHT / 2
                });
                launchPoints.push({
                    x: player.x + player.width - 30 - player.width * 0.05,
                    y: player.y + player.height * 0.35 + MISSILE_HEIGHT / 2
                });
            }
            if (playerUpgradeLevel >= 6) { // Top mounted pods
                const turretCenterX = player.x - player.width / 2 + player.width * 0.6;
                let currentTurretHeight = player.height * 0.45; // Base height for calculations
                let turretTopWidth = player.width * 0.5; // Base width for calculations
                if (playerUpgradeLevel < 2) { turretTopWidth = player.width * 0.4; }
                else if (playerUpgradeLevel < 5) { turretTopWidth = player.width * 0.45; }
                else { currentTurretHeight = player.height * 0.5; turretTopWidth = player.width * 0.5; }

                launchPoints.push({
                    x: turretCenterX - turretTopWidth / 2 + 10 + 40, // End of top-left pod
                    y: player.y - currentTurretHeight * 0.8 - 10 + MISSILE_HEIGHT / 2 // Top of turret
                });
                launchPoints.push({
                    x: turretCenterX + turretTopWidth / 2 - 40 - 10 + 40, // End of top-right pod
                    y: player.y - currentTurretHeight * 0.8 - 10 + MISSILE_HEIGHT / 2 // Top of turret
                });
            }
            
            // For each launch point, create a missile
            for (const launchPoint of launchPoints) {
                projectiles.push({
                    x: launchPoint.x,
                    y: launchPoint.y,
                    vx: MISSILE_SPEED_X,
                    vy: MISSILE_SPEED_Y_INITIAL,
                    targetX: targetZombie.x + targetZombie.width / 2, // Corrected to targetZombie
                    targetY: targetZombie.y + targetZombie.height / 2, // Corrected to targetZombie
                    width: MISSILE_WIDTH,
                    height: MISSILE_HEIGHT,
                    color: '#ff0000', // Red missile
                    damage: MISSILE_DAMAGE,
                    type: 'missile'
                });
            }

            player.canFireMissile = false;
            player.currentMissileCooldown = MISSILE_COOLDOWN;
        }


        /**
         * Starts the game loop.
         */
        function startGame() {
            resetGame();
            gameRunning = true;
            startButton.style.display = 'none';
            restartButton.style.display = 'none';
            lastZombieSpawnTime = performance.now();
            lastUpdateTime = performance.now();
            gameLoop();
        }

        /**
         * Ends the game and displays the game over screen.
         */
        function endGame() {
            gameOver = true;
            gameRunning = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            finalScoreDisplay.textContent = `Final Score: ${score}`;
            gameOverWaveDisplay.textContent = `Survived Waves: ${currentWave}`;
            finalBestScoreDisplay.textContent = `Best Score: ${bestScore}`;

            gameOverScreen.style.display = 'flex';
            restartButton.style.display = 'block';

            if (score > bestScore) {
                setHighScore(score);
            }
        }

        /**
         * Advances to the next wave, increasing difficulty and victim count.
         */
        function nextWave() {
            currentWave++;
            waveDisplay.textContent = `Wave: ${currentWave}`;
            zombieSpeed += 0.1;
            zombieSpawnRate = Math.max(800, zombieSpawnRate - 50);
            
            if (currentWave % 2 === 0) {
                victims.push({
                    x: DEFENSE_LINE_X - (VICTIM_WIDTH * 1.5 * (victims.length + 1)), // Position victims behind defense line
                    y: VICTIM_Y,
                    width: VICTIM_WIDTH,
                    height: VICTIM_HEIGHT,
                    health: 100,
                    maxHealth: 100,
                    isAlive: true
                });
            }
            victimCountDisplay.textContent = `Victims: ${victims.filter(v => v.isAlive).length}`;

            // Update zombie visual tier based on wave
            const nextZombieTierIndex = ZOMBIE_VISUAL_TIERS.findIndex(tier => currentWave >= tier.wave && currentWave < (ZOMBIE_VISUAL_TIERS[ZOMBIE_VISUAL_TIERS.indexOf(tier) + 1]?.wave || Infinity));
            if (nextZombieTierIndex !== -1 && nextZombieTierIndex !== currentZombieTier) {
                currentZombieTier = nextZombieTierIndex;
                console.log(`Zombie visual tier upgraded to: ${ZOMBIE_VISUAL_TIERS[currentZombieTier].name}`);
            }

            // Update background theme based on wave
            const nextBackgroundThemeIndex = BACKGROUND_THEMES.findIndex(theme => currentWave >= theme.wave && currentWave < (BACKGROUND_THEMES[BACKGROUND_THEMES.indexOf(theme) + 1]?.wave || Infinity));
            if (nextBackgroundThemeIndex !== -1 && nextBackgroundThemeIndex !== currentBackgroundThemeIndex) {
                currentBackgroundThemeIndex = nextBackgroundThemeIndex;
                console.log(`Background theme changed to: ${BACKGROUND_THEMES[currentBackgroundThemeIndex].name}`);
            }

            console.log(`Wave ${currentWave}: Zombie Speed = ${zombieSpeed.toFixed(1)}, Spawn Rate = ${zombieSpawnRate}ms`);
        }

        /**
         * Spawns a new zombie (or zombie tank).
         */
        function spawnZombie() {
            const randomStreetY = STREET_MIN_Y_DRAW + Math.random() * (STREET_MAX_Y_DRAW - STREET_MIN_Y_DRAW);
            
            if (currentWave >= ZOMBIE_TANK_SPAWN_WAVE && Math.random() < ZOMBIE_TANK_SPAWN_CHANCE) {
                // Spawn Zombie Tank
                const zombieY = randomStreetY - ZOMBIE_TANK_HEIGHT;
                zombies.push({
                    x: GAME_WIDTH,
                    y: zombieY,
                    width: ZOMBIE_TANK_WIDTH,
                    height: ZOMBIE_TANK_HEIGHT,
                    health: ZOMBIE_TANK_HEALTH,
                    maxHealth: ZOMBIE_TANK_HEALTH,
                    speed: ZOMBIE_TANK_SPEED,
                    type: 'zombieTank'
                });
            } else {
                // Spawn Regular Zombie
                const zombieY = randomStreetY - ZOMBIE_HEIGHT;
                zombies.push({
                    x: GAME_WIDTH,
                    y: zombieY,
                    width: ZOMBIE_WIDTH,
                    height: ZOMBIE_HEIGHT,
                    health: ZOMBIE_INITIAL_HEALTH * (1 + (currentWave - 1) * 0.15), // Increased health scaling
                    maxHealth: ZOMBIE_INITIAL_HEALTH * (1 + (currentWave - 1) * 0.15),
                    speed: zombieSpeed,
                    type: 'regular'
                });
            }
        }

        /**
         * Creates blood particles at a given position.
         */
        function createBloodParticles(x, y) {
            for (let i = 0; i < BLOOD_PARTICLE_COUNT; i++) {
                bloodParticles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * BLOOD_PARTICLE_SPEED_MAX * 2,
                    vy: (Math.random() - 0.5) * BLOOD_PARTICLE_SPEED_MAX * 2,
                    life: BLOOD_PARTICLE_LIFESPAN,
                    size: Math.random() * (BLOOD_PARTICLE_SIZE_MAX - BLOOD_PARTICLE_SIZE_MIN) + BLOOD_PARTICLE_SIZE_MIN,
                    color: Math.random() > 0.5 ? '#8b0000' : '#b22222'
                });
            }
        }

        /**
         * Updates the position and lifespan of all blood particles.
         */
        function updateBloodParticles(deltaTime) {
            bloodParticles.forEach(p => {
                p.x += p.vx * (deltaTime / 16);
                p.y += p.vy * (deltaTime / 16);
                p.vy += 0.2 * (deltaTime / 16);
                p.life -= (deltaTime / 16);
            });
            bloodParticles = bloodParticles.filter(p => p.life > 0);
        }

        /**
         * Creates explosion particles at a given position.
         */
        function createExplosionParticles(x, y) {
            for (let i = 0; i < EXPLOSION_PARTICLE_COUNT; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * EXPLOSION_PARTICLE_SPEED_MAX;
                explosions.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: EXPLOSION_PARTICLE_LIFESPAN,
                    size: Math.random() * (EXPLOSION_PARTICLE_SIZE_MAX - EXPLOSION_PARTICLE_SIZE_MIN) + EXPLOSION_PARTICLE_SIZE_MIN,
                    color: ['#ff4500', '#ffa500', '#ffff00', '#8b0000'][Math.floor(Math.random() * 4)] // Orange, yellow, red
                });
            }
        }

        /**
         * Updates the position and lifespan of all explosion particles.
         */
        function updateExplosionParticles(deltaTime) {
            explosions.forEach(p => {
                p.x += p.vx * (deltaTime / 16);
                p.y += p.vy * (deltaTime / 16);
                p.life -= (deltaTime / 16);
                // Reduce velocity over time for a more natural fade
                p.vx *= 0.98;
                p.vy *= 0.98;
            });
            explosions = explosions.filter(p => p.life > 0);
        }

        /**
         * Handles upgrading the tank's abilities and appearance.
         */
        function upgradeTank() {
            const nextUpgradeLevel = playerUpgradeLevel + 1;
            console.log(`--- Attempting Upgrade ---`);
            console.log(`Current Level: ${playerUpgradeLevel} (${TANK_UPGRADE_LEVELS[playerUpgradeLevel].name})`);
            console.log(`Current Score: ${score}`);
            if (nextUpgradeLevel < TANK_UPGRADE_LEVELS.length) {
                console.log(`Next Level: ${nextUpgradeLevel} (${TANK_UPGRADE_LEVELS[nextUpgradeLevel].name})`);
                console.log(`Cost for next upgrade: ${UPGRADE_SCORE_THRESHOLDS[playerUpgradeLevel]} pts`);
            } else {
                console.log("Already at max upgrade level.");
            }

            // Check if there are more upgrade levels and if player has enough score
            if (nextUpgradeLevel < TANK_UPGRADE_LEVELS.length && score >= UPGRADE_SCORE_THRESHOLDS[playerUpgradeLevel]) {
                score -= UPGRADE_SCORE_THRESHOLDS[playerUpgradeLevel]; // Deduct score for upgrade
                scoreDisplay.textContent = `Score: ${score}`;
                
                playerUpgradeLevel = nextUpgradeLevel;
                const newStats = TANK_UPGRADE_LEVELS[playerUpgradeLevel];
                player.barrelLength = newStats.barrelLength;
                BULLET_SPEED = newStats.bulletSpeed;
                BULLET_DAMAGE = newStats.bulletDamage;
                FIRE_RATE_COOLDOWN = newStats.fireRate;

                console.log(`Upgrade successful! Tank is now ${newStats.name}.`);
                console.log(`New Score: ${score}`);
                console.log(`New Bullet Speed: ${BULLET_SPEED}, Damage: ${BULLET_DAMAGE}, Fire Rate: ${FIRE_RATE_COOLDOWN}`);
                console.log(`Laser Enabled: ${newStats.laserEnabled}, Missile Enabled: ${newStats.missileEnabled}`);
            } else {
                console.log("Upgrade failed: Not enough score or already at max level.");
            }

            // Update upgrade button text for next level or hide if max
            if (playerUpgradeLevel < TANK_UPGRADE_LEVELS.length - 1) { // -1 because length is 9, levels 0-8. Next upgrade cost is at current level's index
                upgradeButton.textContent = `Upgrade Tank (${UPGRADE_SCORE_THRESHOLDS[playerUpgradeLevel]} pts)`;
                upgradeButton.style.display = 'none'; // Hide until next threshold is met
            } else {
                upgradeButton.textContent = `Tank MAX!`;
                upgradeButton.style.display = 'none'; // Hide if max level reached
            }
        }

        /**
         * Main game update logic.
         */
        function update(currentTime) {
            if (!gameRunning) return;

            const deltaTime = currentTime - lastUpdateTime;
            lastUpdateTime = currentTime;

            // Update tank health display
            tankHealthDisplay.textContent = `Tank HP: ${player.health}`;

            // Check for upgrade availability and update button visibility
            if (playerUpgradeLevel < TANK_UPGRADE_LEVELS.length - 1 && score >= UPGRADE_SCORE_THRESHOLDS[playerUpgradeLevel]) {
                upgradeAvailable = true;
                upgradeButton.style.display = 'block';
            } else {
                upgradeAvailable = false;
                if (playerUpgradeLevel >= TANK_UPGRADE_LEVELS.length -1) { 
                     upgradeButton.style.display = 'none'; // Hide if max level reached
                } else {
                    upgradeButton.style.display = 'none'; // Hide if not enough score
                }
            }

            // Update tank movement (keyboard/touch buttons)
            if (player.isMovingLeft) {
                player.x = Math.max(player.x - TANK_MOVE_SPEED * (deltaTime / 16), player.width / 2);
            } else if (player.isMovingRight) {
                player.x = Math.min(player.x + TANK_MOVE_SPEED * (deltaTime / 16), GAME_WIDTH - player.width / 2);
            }

            if (player.isMovingUp) {
                player.y = Math.max(player.y - TANK_MOVE_SPEED * (deltaTime / 16), STREET_MIN_Y_DRAW - player.height / 2);
            } else if (player.isMovingDown) {
                player.y = Math.min(player.y + TANK_MOVE_SPEED * (deltaTime / 16), STREET_MAX_Y_DRAW - player.height / 2);
            }

            // Update tread animation offset
            if (player.isMovingLeft || player.isMovingRight || player.isMovingUp || player.isMovingDown) {
                treadOffset = (treadOffset + TREAD_ANIMATION_SPEED * (deltaTime / 16));
                if (treadOffset >= 15) treadOffset -= 15;
            } else {
                if (treadOffset !== 0) {
                    const decay = TREAD_ANIMATION_SPEED * 0.5 * (deltaTime / 16);
                    if (treadOffset > 0) treadOffset = Math.max(0, treadOffset - decay);
                    else treadOffset = Math.min(0, treadOffset + decay);
                    if (Math.abs(treadOffset) < 0.1) treadOffset = 0;
                }
            }


            // Update primary bullet cooldown
            if (!player.canFirePrimary) {
                player.currentPrimaryCooldown -= deltaTime;
                if (player.currentPrimaryCooldown <= 0) {
                    player.canFirePrimary = true;
                }
            }
            // Update laser cooldown and fire if ready and enabled (automatic)
            if (!player.canFireLaser) {
                player.currentLaserCooldown -= deltaTime;
                if (player.currentLaserCooldown <= 0) {
                    player.canFireLaser = true;
                }
            }
            if (TANK_UPGRADE_LEVELS[playerUpgradeLevel].laserEnabled && player.canFireLaser) {
                fireLaser();
            }

            // Update missile cooldown and fire if ready and enabled (automatic)
            if (!player.canFireMissile) {
                player.currentMissileCooldown -= deltaTime;
                if (player.currentMissileCooldown <= 0) {
                    player.canFireMissile = true;
                }
            }
            if (TANK_UPGRADE_LEVELS[playerUpgradeLevel].missileEnabled && player.canFireMissile) {
                fireMissile();
            }

            // Move projectiles
            projectiles.forEach(p => {
                if (p.type === 'missile') {
                    p.x += p.vx * (deltaTime / 16);
                    p.vy += MISSILE_GRAVITY * (deltaTime / 16); // Apply gravity
                    p.y += p.vy * (deltaTime / 16);

                    // Basic homing/arc correction towards targetX/Y
                    // Only adjust if target is still in front of the missile
                    if (p.x < p.targetX) {
                        const dx = p.targetX - p.x;
                        const dy = p.targetY - p.y;
                        // Steer vertically towards the target if needed, but not too aggressively
                        const steeringFactor = 0.05; // Less aggressive steering
                        p.vy += (dy - p.vy) * steeringFactor * (deltaTime / 16);
                        // Cap vertical speed to prevent wild oscillations
                        p.vy = Math.max(-MISSILE_SPEED_X, Math.min(MISSILE_SPEED_X, p.vy));
                    }

                } else {
                    p.x += p.speed * (deltaTime / 16);
                }
            });
            projectiles = projectiles.filter(p => p.x < GAME_WIDTH && p.y > -50); // Filter out missiles that flew off screen vertically

            // Move zombies (horizontally)
            zombies.forEach(zombie => {
                zombie.x -= zombie.speed * (deltaTime / 16);

                // Zombie-Victim collision: if zombie crosses the defense line
                if (zombie.x <= DEFENSE_LINE_X) {
                    let hitVictim = false; // Corrected variable name
                    for (let i = 0; i < victims.length; i++) {
                        const victim = victims[i];
                        if (victim.isAlive) {
                            // Simple collision check for zombie hitting victim's general area
                            if (zombie.x < victim.x + victim.width &&
                                zombie.x + zombie.width > victim.x &&
                                zombie.y < victim.y + victim.height &&
                                zombie.y + zombie.height > victim.y) {

                                // Zombie caught a victim!
                                victim.health -= VICTIM_DAMAGE_PER_ZOMBIE;
                                if (victim.health <= 0) {
                                    victim.isAlive = false;
                                    player.health -= 25;
                                    tankHealthDisplay.textContent = `Tank HP: ${player.health}`;
                                    victimCountDisplay.textContent = `Victims: ${victims.filter(v => v.isAlive).length}`;
                                }
                                hitVictim = true; // Corrected variable name
                                break;
                            }
                        }
                    }
                    if (hitVictim) { // Corrected variable name
                        if (zombie.type === 'zombieTank') { // Zombie tank takes damage from hitting victims
                            zombie.health -= 50; // Zombie tank takes some damage but is not instantly removed
                            if (zombie.health <=0) {
                                createBloodParticles(zombie.x + zombie.width / 2, zombie.y + zombie.height / 2);
                                createExplosionParticles(zombie.x + zombie.width / 2, zombie.y + zombie.height / 2);
                                zombies = zombies.filter(z => z !== zombie);
                                score += 100; // Extra score for tank
                                scoreDisplay.textContent = `Score: ${score}`;
                            }
                        } else {
                            zombies = zombies.filter(z => z !== zombie); // Regular zombies are removed
                            createBloodParticles(zombie.x + zombie.width / 2, zombie.y + zombie.height / 2);
                        }
                    }
                }
            });

            zombies = zombies.filter(zombie => zombie.x + zombie.width > 0);

            // Projectile-Zombie collisions (handle all projectile types)
            for (let pIndex = projectiles.length - 1; pIndex >= 0; pIndex--) {
                const p = projectiles[pIndex];
                for (let zIndex = zombies.length - 1; zIndex >= 0; zIndex--) {
                    const zombie = zombies[zIndex];

                    let projectileHit = false;
                    // Collision check (AABB for simplicity)
                    if (p.type === 'bullet') {
                        // For bullets, using p.radius for circular check around center
                        // This simplifies the collision for a small, roundish bullet compared to its drawn rectangle.
                        const bulletCenterX = p.x;
                        const bulletCenterY = p.y;
                        const zombieCenterX = zombie.x + zombie.width / 2;
                        const zombieCenterY = zombie.y + zombie.height / 2;
                        const dx = bulletCenterX - zombieCenterX;
                        const dy = bulletCenterY - zombieCenterY;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // Approximate collision for bullet (circle vs rect)
                        if (distance < p.radius + Math.max(zombie.width, zombie.height) / 3) {
                            projectileHit = true;
                        }
                    } else if (p.type === 'laser') {
                        // AABB for laser
                        if (p.x + p.width > zombie.x &&
                            p.x < zombie.x + zombie.width &&
                            p.y + p.height > zombie.y &&
                            p.y < zombie.y + zombie.height) {
                            projectileHit = true;
                        }
                    } else if (p.type === 'missile') {
                        // AABB for missile
                        if (p.x + p.width > zombie.x &&
                            p.x < zombie.x + zombie.width &&
                            p.y + p.height > zombie.y &&
                            p.y < zombie.y + zombie.height) {
                            projectileHit = true;
                        }
                    }

                    if (projectileHit) {
                        zombie.health -= p.damage;
                        projectiles.splice(pIndex, 1); // Remove projectile on hit

                        if (zombie.health <= 0) {
                            score += (zombie.type === 'zombieTank' ? 100 : 10); // More score for zombie tank
                            scoreDisplay.textContent = `Score: ${score}`;
                            createBloodParticles(zombie.x + zombie.width / 2, zombie.y + zombie.height / 2);
                            if (p.type === 'missile') { // Missiles create explosion on hit
                                createExplosionParticles(zombie.x + zombie.width / 2, zombie.y + zombie.height / 2);
                            }
                            zombies.splice(zIndex, 1); // Remove zombie
                        } else if (p.type === 'missile') { // Missile explodes even if zombie is not dead
                            createExplosionParticles(p.x, p.y);
                        }
                        break; // Only hit one zombie per projectile
                    }
                }
            }

            // Check for wave progression
            if (zombies.length === 0 && (currentTime - lastZombieSpawnTime) > zombieSpawnRate && score >= currentWave * 100) {
                nextWave();
            } else if (zombies.length === 0 && (currentTime - lastZombieSpawnTime) > zombieSpawnRate) {
                spawnZombie();
                lastZombieSpawnTime = currentTime;
            }

            // Spawn new zombies if overdue
            if (currentTime - lastZombieSpawnTime > zombieSpawnRate) {
                spawnZombie();
                lastZombieSpawnTime = currentTime;
            }

            // Update particles
            updateBloodParticles(deltaTime);
            updateExplosionParticles(deltaTime);

            // Game Over conditions: All victims dead OR Tank health is 0
            if (victims.filter(v => v.isAlive).length === 0 || player.health <= 0) {
                endGame();
            }
        }

        /**
         * Main game loop.
         */
        function gameLoop(currentTime) {
            if (!gameOver) {
                update(currentTime);
                draw();
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        // --- Event Listeners ---

        // Tank movement (keyboard)
        document.addEventListener('keydown', (e) => {
            if (!gameRunning || gameOver) return;
            if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                player.isMovingLeft = true;
            } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                player.isMovingRight = true;
            } else if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') {
                player.isMovingUp = true;
            } else if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') {
                player.isMovingDown = true;
            } else if (e.key.toLowerCase() === 'm') {
                fireLaser(); // Manual laser fire
            } else if (e.key.toLowerCase() === 'r') {
                fireMissile(); // Manual missile fire
            } else if (e.key === ' ' || e.key === 'Spacebar') { // Spacebar for main cannon
                firePrimaryBullet();
                e.preventDefault(); // Prevent page scrolling
            }
        });

        document.addEventListener('keyup', (e) => {
            if (!gameRunning || gameOver) return;
            if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                player.isMovingLeft = false;
            } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                player.isMovingRight = false;
            } else if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') {
                player.isMovingUp = false;
            } else if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') {
                player.isMovingDown = false;
            }
        });

        // Shooting (Desktop: click on canvas) - Only fires primary weapon
        window.addEventListener('click', (e) => {
            if (!gameRunning || gameOver) return;
            // Check if the click occurred within the canvas boundaries, or if it's the shoot button
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            const isCanvasClick = clickX >= 0 && clickX <= GAME_WIDTH && clickY >= 0 && clickY <= GAME_HEIGHT;

            if (isCanvasClick) {
                firePrimaryBullet();
            }
        });

        // --- Mobile Control Buttons Event Listeners ---
        function bindMovementButton(button, directionFlag) {
            if (!button) return; // Add a check to ensure the button exists
            // Use { passive: false } for touch events to allow preventDefault
            button.addEventListener('touchstart', (e) => { e.preventDefault(); player[directionFlag] = true; }, { passive: false });
            button.addEventListener('touchend', (e) => { e.preventDefault(); player[directionFlag] = false; }, { passive: false });
            button.addEventListener('mousedown', (e) => { e.preventDefault(); player[directionFlag] = true; });
            button.addEventListener('mouseup', (e) => { e.preventDefault(); player[directionFlag] = false; });
            button.addEventListener('mouseleave', (e) => { e.preventDefault(); player[directionFlag] = false; });
        }


        // These event listeners will also be assigned inside window.onload after elements are retrieved.


        // --- Firebase Initialization ---
        window.onload = async function() {
            // Assign DOM elements inside window.onload to ensure they are available
            canvas = document.getElementById('gameCanvas');
            // Add a check for canvas before proceeding
            if (!canvas) {
                console.error("Canvas element not found! Cannot initialize game.");
                userIdDisplay.textContent = `User ID: Canvas Error`;
                return; // Stop execution if canvas is not found
            }
            ctx = canvas.getContext('2d');
            // Set canvas dimensions AFTER getting the canvas element
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;

            scoreDisplay = document.getElementById('scoreDisplay');
            bestScoreDisplay = document.getElementById('bestScoreDisplay');
            tankHealthDisplay = document.getElementById('tankHealthDisplay');
            victimCountDisplay = document.getElementById('victimCountDisplay');
            waveDisplay = document.getElementById('waveDisplay');
            startButton = document.getElementById('startButton');
            upgradeButton = document.getElementById('upgradeButton');
            restartButton = document.getElementById('restartButton');
            gameOverScreen = document.getElementById('game-over-screen');
            finalScoreDisplay = document.getElementById('final-score');
            gameOverWaveDisplay = document.getElementById('game-over-wave');
            finalBestScoreDisplay = document.getElementById('final-best-score');
            userIdDisplay = document.getElementById('userIdDisplay');

            moveUpBtn = document.getElementById('moveUpBtn');
            moveDownBtn = document.getElementById('moveDownBtn');
            moveLeftBtn = document.getElementById('moveLeftBtn');
            moveRightBtn = document.getElementById('moveRightBtn');
            shootBtn = document.getElementById('shootBtn');

            bindMovementButton(moveUpBtn, 'isMovingUp');
            bindMovementButton(moveDownBtn, 'isMovingDown');
            bindMovementButton(moveLeftBtn, 'isMovingLeft');
            bindMovementButton(moveRightBtn, 'isMovingRight');

            if (shootBtn) { // Double check shootBtn existence
                shootBtn.addEventListener('click', (e) => {
                    e.preventDefault(); // Prevent default touch behavior
                    firePrimaryBullet(); // Mobile shoot button fires primary
                });
            }

            if (startButton) startButton.addEventListener('click', startGame);
            if (restartButton) restartButton.addEventListener('click', startGame);
            if (upgradeButton) upgradeButton.addEventListener('click', upgradeTank);


            try {
                const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
                // Check if projectId is missing before initializing Firebase
                if (!firebaseConfig.projectId && firebaseConfig !== {}) {
                    console.warn("Firebase 'projectId' is missing in the provided configuration. Score saving may not work correctly. Please ensure __firebase_config is properly set in the environment.");
                    userIdDisplay.textContent = `User ID: Firebase (No ProjectId)`;
                }

                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Use onAuthStateChanged to ensure game starts only after initial auth state is determined
                onAuthStateChanged(auth, async (user) => {
                    if (!initialAuthCheckCompleted) { // Ensure this block runs only once for initial setup
                        if (user) {
                            userId = user.uid;
                            isFirebaseReady = true;
                            if (userIdDisplay) userIdDisplay.textContent = `User ID: ${userId.substring(0, 8)}...`;
                            await getHighScore();
                        } else {
                            // If no user initially, attempt custom token sign-in, then anonymous
                            try {
                                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                                    await signInWithCustomToken(auth, __initial_auth_token);
                                    userId = auth.currentUser?.uid; // Update userId if custom token worked
                                    isFirebaseReady = true;
                                    if (userIdDisplay) userIdDisplay.textContent = `User ID: ${userId ? userId.substring(0, 8) + '...' : 'Anonymous'}`;
                                    await getHighScore(); // Fetch high score after successful sign-in
                                } else {
                                    // No custom token provided, sign in anonymously directly
                                    await signInAnonymously(auth);
                                    userId = auth.currentUser?.uid;
                                    isFirebaseReady = true;
                                    if (userIdDisplay) userIdDisplay.textContent = `User ID: ${userId.substring(0, 8)}... (Anonymous)`;
                                    await getHighScore();
                                }
                            } catch (e) {
                                // If custom token sign-in fails, immediately try anonymous.
                                // This specific error (auth/invalid-claims) can be a common case if the token is for demonstration.
                                console.warn("Custom token sign-in failed (this is expected if token is invalid or missing), falling back to anonymous:", e);
                                try {
                                    await signInAnonymously(auth);
                                    userId = auth.currentUser?.uid;
                                    isFirebaseReady = true;
                                    if (userIdDisplay) userIdDisplay.textContent = `User ID: ${userId.substring(0, 8)}... (Anonymous)`;
                                    await getHighScore();
                                } catch (anonymousError) {
                                    console.error("Anonymous sign-in also failed:", anonymousError);
                                    if (userIdDisplay) userIdDisplay.textContent = `User ID: Not Signed In (Auth Failed)`;
                                    isFirebaseReady = false;
                                }
                            }
                        }
                        initialAuthCheckCompleted = true; // Mark initial auth check as completed
                        resetGame(); // Start the game after the initial auth state is set
                    }
                });
            } catch (error) {
                console.error("Firebase initialization failed (Caught in top-level try/catch):", error);
                if (userIdDisplay) userIdDisplay.textContent = `User ID: Firebase Init Error`;
                isFirebaseReady = false;
            }
        };
    </script>
</body>
</html>
